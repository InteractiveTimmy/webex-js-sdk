import {
  SERVICE_CATALOGS,
  SERVICE_CATALOGS_ENUM_TYPES as ECET
} from './constants';
import ServiceHost from './service-host';

/**
 * The parameter transfer object for {@link ServiceCatalogs#mapRemoteCatalog}.
 * This object is shaped to match the object returned from the **U2C** service.
 *
 * @typedef {Record<string, string>} RSL
 * @typedef {Record<string, Array<Record<string, number | string>>>} RHC
 *
 * @typedef {Object} MapRemoteCatalogPTO
 * @property {string} MapRemoteCatalogPTO.catalog - Service catalog name.
 * @property {RSL} MapRemoteCatalogPTO.serviceLinks - Service links.
 * @property {RHC} MapRemoteCatalogPTO.hostCatalog - Service host catalog.
 */

/**
 * @class
 * @classdesc - Manages a collection of {@link ServiceHost} class objects.
 */
export default class ServiceCatalogs {
  /**
   * Generate a new {@link ServiceHost}.
   *
   * @public
   * @constructor
   * @memberof ServiceHost
   */
  constructor() {
    /**
     * The collection of managed {@link ServiceHost}s.
     *
     * @instance
     * @type {Array<ServiceHost>}
     * @private
     * @memberof ServiceCatalogs
     */
    this.hosts = [];
  }

  /**
   * Load a formatted array of {@link ServiceHost} constructor parameter
   * transfer objects as instances of {@link ServiceHost} class objects to the
   * {@link ServiceCatalogs#hosts} array.
   *
   * @public
   * @memberof ServiceCatalogs
   * @param {Array<ServiceHost.ConstructorPTO>} hosts
   * @returns {this}
   */
  load(hosts = []) {
    // Validate that the provided hosts are eligible to be loaded.
    const validHosts = hosts.filter((host) => !!(
      ServiceCatalogs.mapCatalogName({
        id: host.catalog,
        type: ECET.STRING
      })));

    // Load the eligible hosts.
    this.hosts.push(
      ...validHosts.map((loadableHost) => new ServiceHost(loadableHost))
    );

    return this;
  }

  /**
   * Convert a {@link SERVICE_CATALOGS} identifier or value to its associated
   * idenfier or value.
   *
   * @public
   * @static
   * @memberof ServiceCatalogs
   * @param {Object} pto - The parameter transfer object.
   * @property {string | number} pto.id - The identifier to convert in the enum.
   * @property {ECET.STRING | ECET.NUMBER} pto.type - The desired output.
   * @returns {string|number} - The matching enum value or index.
   */
  static mapCatalogName({id, type}) {
    // Validate that the id is a number.
    if (typeof id === 'number') {
      // Validate that the desired type is a number.
      if (type === ECET.NUMBER) {
        return (SERVICE_CATALOGS[id] !== undefined) ? id : undefined;
      }

      // Validate that the desired type is a string.
      if (type === ECET.STRING) {
        return SERVICE_CATALOGS[id];
      }
    }

    // Validate that the id is a string.
    if (typeof id === 'string') {
      // Validate that the desired type is a string.
      if (type === ECET.STRING) {
        return SERVICE_CATALOGS.includes(id) ? id : undefined;
      }

      // Validate that the desired type is a number.
      if (type === ECET.NUMBER) {
        return (
          (SERVICE_CATALOGS.includes(id)) ?
            SERVICE_CATALOGS.indexOf(id) :
            undefined
        );
      }
    }

    return undefined;
  }

  /**
   * Generate a formatted array based on the object received from the **U2C**
   * service for usage in the {@link ServiceCatalogs#load} method.
   *
   * @public
   * @static
   * @memberof ServiceCatalogs
   * @param {MapRemoteCatalogPTO} pto - The parameter transfer object.
   * @throws - If the target catalog does not exist.
   * @returns {Array<ServiceHost#ServiceHostConstructorPTO>}
   */
  static mapRemoteCatalog({catalog, hostCatalog, serviceLinks}) {
    // Collect the service catalog name if needed.
    const catalogIndex = ServiceCatalogs.mapCatalogName({
      id: catalog,
      type: ECET.STRING
    });

    // Validate that the target catalog exists.
    if (!SERVICE_CATALOGS.includes(catalogIndex)) {
      throw new Error(`service-catalogs: '${catalog}' is not a valid catalog`);
    }

    // Map the remote catalog to a mountable host array.
    return Object.keys(hostCatalog).reduce((output, key) => {
      output.push(
        ...hostCatalog[key].map((host) => ({
          catalog: catalogIndex,
          defaultUri: serviceLinks[host.id.split(':')[3]],
          hostGroup: key,
          id: host.id,
          priority: host.priority,
          uri: host.host
        }))
      );

      return output;
    }, []);
  }
}
