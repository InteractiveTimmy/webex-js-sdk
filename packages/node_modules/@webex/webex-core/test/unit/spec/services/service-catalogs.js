import {assert} from '@webex/test-helper-chai';
import {ServiceCatalogs, serviceConstants} from '@webex/webex-core';

const {SERVICE_CATALOGS, SERVICE_CATALOGS_ENUM_TYPES: SCET} = serviceConstants;

describe('webex-core', () => {
  describe('ServiceCatalogs', () => {
    let fixture;
    let fixtureHosts;
    let serviceCatalogs;

    before('generate fixture', () => {
      fixture = {
        serviceLinks: {
          'example-service-a-name': 'http://example-service-a.com/',
          'example-service-b-name': 'http://example-service-b.com/'
        },
        hostCatalog: {
          'example-service-a': [
            {
              host: 'example-service-a-h1.com',
              id: 'head:group:cluster-a-h1:example-service-a-name',
              priority: 5
            },
            {
              host: 'example-service-a-h2.com',
              id: 'head:group:cluster-a-h2:example-service-a-name',
              priority: 3
            }
          ],
          'example-service-b': [
            {
              host: 'example-service-b-h1.com',
              id: 'head:group:cluster-b-h1:example-service-b-name',
              priority: 5
            },
            {
              host: 'example-service-b-h2.com',
              id: 'head:group:cluster-b-h2:example-service-b-name',
              priority: 3
            }
          ],
          'example-service-c': [
            {
              host: 'example-service-c-h1.com',
              id: 'head:group:cluster-c-h1:example-service-a-name',
              priority: 5
            },
            {
              host: 'example-service-c-h2.com',
              id: 'head:group:cluster-c-h2:example-service-a-name',
              priority: 3
            }
          ]
        }
      };

      fixtureHosts = Object.keys(fixture.hostCatalog)
        .reduce((output, key) => {
          output.push(...fixture.hostCatalog[key]);

          return output;
        }, []);
    });

    beforeEach('initialize a service catalog', () => {
      serviceCatalogs = new ServiceCatalogs();
    });

    describe('class members', () => {
      describe('#hosts', () => {
        it('should be an array', () => {
          assert.isArray(serviceCatalogs.hosts);
        });
      });
    });

    describe('#filterActive()', () => {
      let hostList;
      let failedHost;
      let filteredHosts;

      beforeEach('generate the service host class objects', () => {
        hostList = ServiceCatalogs.mapRemoteCatalog({
          catalog: SERVICE_CATALOGS[0],
          ...fixture
        });

        serviceCatalogs.load(hostList);
        failedHost = serviceCatalogs.hosts[0];
        failedHost.setStatus({failed: true, replaced: true});
      });

      it('should return only active hosts when called without params', () => {
        filteredHosts = serviceCatalogs.filterActive();

        assert.equal(filteredHosts.length, hostList.length);
      });

      it('should return only active hosts when called with true', () => {
        filteredHosts = serviceCatalogs.filterActive(true);

        assert.isBelow(filteredHosts.length, hostList.length);
        assert.notInclude(filteredHosts, failedHost);
      });

      it('should return only inactive hosts when active is false', () => {
        filteredHosts = serviceCatalogs.filterActive(false);

        assert.equal(filteredHosts.length, 1);
        assert.include(filteredHosts[0], failedHost);
      });
    });

    describe('#filterCatalog()', () => {
      let filteredHosts;
      let hostsCustomA;
      let hostsCustomB;

      beforeEach('generate the service host class objects', () => {
        hostsCustomA = ServiceCatalogs.mapRemoteCatalog({
          catalog: SERVICE_CATALOGS[0],
          ...fixture
        });

        hostsCustomB = ServiceCatalogs.mapRemoteCatalog({
          catalog: SERVICE_CATALOGS[1],
          ...fixture
        });

        serviceCatalogs.load(hostsCustomA);
        serviceCatalogs.load(hostsCustomB);
      });

      it('should return all hosts when called without params', () => {
        filteredHosts = serviceCatalogs.filterCatalog();

        assert.equal(filteredHosts.length, serviceCatalogs.hosts.length);
        assert.deepEqual(filteredHosts, serviceCatalogs.hosts);
      });

      it('should return only service hosts in the specific catalog', () => {
        filteredHosts = serviceCatalogs.filterCatalog(SERVICE_CATALOGS[0]);

        assert.equal(filteredHosts.length, hostsCustomA.length);
        assert.isTrue(filteredHosts.every(
          (host) => host.catalog === SERVICE_CATALOGS[0]
        ));
      });

      it('should return service hosts for an array of catalogs', () => {
        filteredHosts = serviceCatalogs.filterCatalog(
          [SERVICE_CATALOGS[0], SERVICE_CATALOGS[1]]
        );

        assert.equal(
          filteredHosts.length,
          (hostsCustomA.length + hostsCustomB.length)
        );

        assert.isTrue(filteredHosts.every(
          (host) => [SERVICE_CATALOGS[0], SERVICE_CATALOGS[1]].includes(
            host.catalog
          )
        ));
      });

      it('should return only service hosts from valid catalogs', () => {
        filteredHosts = serviceCatalogs.filterCatalog(
          [SERVICE_CATALOGS[0], 'invalid', -1]
        );

        assert.equal(filteredHosts.length, hostsCustomA.length);
        assert.isTrue(filteredHosts.every(
          (host) => host.catalog === SERVICE_CATALOGS[0]
        ));
      });
    });

    describe('#filterCluster()', () => {
      let filteredHosts;
      let hostFixtureA;
      let hostFixtureB;

      beforeEach('generate the service host class objects', () => {
        serviceCatalogs.load(
          ServiceCatalogs.mapRemoteCatalog({
            catalog: SERVICE_CATALOGS[0],
            ...fixture
          })
        );

        hostFixtureA = fixture.hostCatalog['example-service-a'][0];
        hostFixtureB = fixture.hostCatalog['example-service-b'][1];
      });

      it('should return all hosts when called without params', () => {
        filteredHosts = serviceCatalogs.filterCluster();

        assert.equal(filteredHosts.length, serviceCatalogs.hosts.length);
        assert.deepEqual(filteredHosts, serviceCatalogs.hosts);
      });

      it('should return only service hosts in the specific cluster', () => {
        filteredHosts = serviceCatalogs.filterCluster(hostFixtureA.id);

        assert.equal(filteredHosts.length, 1);
        assert.equal(filteredHosts[0].id, hostFixtureA.id);
      });

      it('should return service hosts for an array of clusters', () => {
        filteredHosts = serviceCatalogs.filterCluster(
          [hostFixtureA.id, hostFixtureB.id]
        );

        assert.equal(filteredHosts.length, 2);
        assert.isTrue(filteredHosts.every(
          (host) => [hostFixtureA.id, hostFixtureB.id].includes(host.id)
        ));
      });

      it('should return only service hosts from valid clusters', () => {
        filteredHosts = serviceCatalogs.filterCluster(
          [hostFixtureA.id, 'invalid', -1]
        );

        assert.equal(filteredHosts.length, 1);
        assert.isTrue(filteredHosts.every(
          (host) => host.id === hostFixtureA.id
        ));
      });
    });

    describe('#load()', () => {
      it('should amend all provided hosts to the hosts array', () => {
        serviceCatalogs.load(ServiceCatalogs.mapRemoteCatalog({
          catalog: SERVICE_CATALOGS[0],
          ...fixture
        }));

        assert.equal(serviceCatalogs.hosts.length, fixtureHosts.length);
      });

      it('should ignore unloadable hosts', () => {
        const unloadables = ServiceCatalogs.mapRemoteCatalog({
          catalog: SERVICE_CATALOGS[0],
          ...fixture
        }).map((unloadable) => ({...unloadable, catalog: 'invalid'}));

        serviceCatalogs.load(unloadables);

        assert.equal(serviceCatalogs.hosts.length, 0);
      });

      it('should return itself', () => {
        assert.equal(serviceCatalogs.load([]), serviceCatalogs);
      });
    });

    describe('static methods', () => {
      describe('#mapCatalogName()', () => {
        let index;
        let name;

        beforeEach(() => {
          index = 0;
          name = SERVICE_CATALOGS[index];
        });

        it('should map an index to the matching name', () => {
          assert.equal(
            ServiceCatalogs.mapCatalogName({id: index, type: SCET.STRING}),
            name
          );
        });

        it('should map an index to the matching index', () => {
          assert.equal(
            ServiceCatalogs.mapCatalogName({id: index, type: SCET.NUMBER}),
            index
          );
        });

        it('should map a name to the matching index', () => {
          assert.equal(
            ServiceCatalogs.mapCatalogName({id: name, type: SCET.NUMBER}),
            index
          );
        });

        it('should map a name to the matching name', () => {
          assert.equal(
            ServiceCatalogs.mapCatalogName({id: name, type: SCET.STRING}),
            name
          );
        });

        it('should return undefined if an index doesn\'t exist', () => {
          assert.isUndefined(
            ServiceCatalogs.mapCatalogName({id: -1, type: SCET.NUMBER})
          );
        });

        it('should return undefined if a name doesn\'t exist', () => {
          assert.isUndefined(
            ServiceCatalogs.mapCatalogName({id: 'invalid', type: SCET.NUMBER})
          );
        });
      });

      describe('#mapRemoteCatalog()', () => {
        it('should return an array', () => {
          const mappedHosts = ServiceCatalogs.mapRemoteCatalog({
            catalog: SERVICE_CATALOGS[0],
            ...fixture
          });

          assert.isArray(mappedHosts);
        });

        it('should include all provided hosts', () => {
          const mappedHosts = ServiceCatalogs.mapRemoteCatalog({
            catalog: SERVICE_CATALOGS[0],
            ...fixture
          });

          assert.equal(mappedHosts.length, fixtureHosts.length);
        });

        it('should not map using an invalid catalog name', () => {
          assert.throws(() => ServiceCatalogs.mapRemoteCatalog({
            catalog: 'invalid',
            ...fixture
          }));
        });

        it('should map catalog indexes to catalog names', () => {
          const catalogIndex = 4;

          const mappedHosts = ServiceCatalogs.mapRemoteCatalog({
            catalog: catalogIndex,
            ...fixture
          });

          assert.equal(
            mappedHosts[0].catalog,
            SERVICE_CATALOGS[catalogIndex]
          );
        });
      });
    });
  });
});
