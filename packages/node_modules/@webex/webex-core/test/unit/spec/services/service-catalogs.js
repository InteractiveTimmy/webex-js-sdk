import {assert} from '@webex/test-helper-chai';
import {ServiceCatalogs, serviceConstants} from '@webex/webex-core';

const {SERVICE_CATALOGS, SERVICE_CATALOGS_ENUM_TYPES: SCET} = serviceConstants;

describe('webex-core', () => {
  describe('ServiceCatalogs', () => {
    let fixture;
    let fixtureHosts;
    let serviceCatalogs;

    before('generate fixture', () => {
      fixture = {
        serviceLinks: {
          'example-service-a-name': 'http://example-service-a.com/',
          'example-service-b-name': 'http://example-service-b.com/'
        },
        hostCatalog: {
          'example-service-a': [
            {
              host: 'example-service-a-h1.com',
              id: 'head:group:cluster-a-h1:example-service-a-name',
              priority: 5
            },
            {
              host: 'example-service-a-h2.com',
              id: 'head:group:cluster-a-h2:example-service-a-name',
              priority: 3
            }
          ],
          'example-service-b': [
            {
              host: 'example-service-b-h1.com',
              id: 'head:group:cluster-b-h1:example-service-b-name',
              priority: 5
            },
            {
              host: 'example-service-b-h2.com',
              id: 'head:group:cluster-b-h2:example-service-b-name',
              priority: 3
            }
          ],
          'example-service-c': [
            {
              host: 'example-service-c-h1.com',
              id: 'head:group:cluster-c-h1:example-service-a-name',
              priority: 5
            },
            {
              host: 'example-service-c-h2.com',
              id: 'head:group:cluster-c-h2:example-service-a-name',
              priority: 3
            }
          ]
        }
      };

      fixtureHosts = Object.keys(fixture.hostCatalog)
        .reduce((output, key) => {
          output.push(...fixture.hostCatalog[key]);

          return output;
        }, []);
    });

    beforeEach('initialize a service catalog', () => {
      serviceCatalogs = new ServiceCatalogs();
    });

    describe('class members', () => {
      describe('#hosts', () => {
        it('should be an array', () => {
          assert.isArray(serviceCatalogs.hosts);
        });
      });
    });

    describe('#load()', () => {
      it('should amend all provided hosts to the hosts array', () => {
        serviceCatalogs.load(ServiceCatalogs.mapRemoteCatalog({
          catalog: 'custom',
          ...fixture
        }));

        assert.equal(serviceCatalogs.hosts.length, fixtureHosts.length);
      });

      it('should ignore unloadable hosts', () => {
        const unloadables = ServiceCatalogs.mapRemoteCatalog({
          catalog: 'custom',
          ...fixture
        }).map((unloadable) => ({...unloadable, catalog: 'invalid'}));

        serviceCatalogs.load(unloadables);

        assert.equal(serviceCatalogs.hosts.length, 0);
      });

      it('should return itself', () => {
        assert.equal(serviceCatalogs.load([]), serviceCatalogs);
      });
    });

    describe('static methods', () => {
      describe('#mapCatalogName()', () => {
        let index;
        let name;

        beforeEach(() => {
          index = 0;
          name = SERVICE_CATALOGS[index];
        });

        it('should map an index to the matching name', () => {
          assert.equal(
            ServiceCatalogs.mapCatalogName({id: index, type: SCET.STRING}),
            name
          );
        });

        it('should map an index to the matching index', () => {
          assert.equal(
            ServiceCatalogs.mapCatalogName({id: index, type: SCET.NUMBER}),
            index
          );
        });

        it('should map a name to the matching index', () => {
          assert.equal(
            ServiceCatalogs.mapCatalogName({id: name, type: SCET.NUMBER}),
            index
          );
        });

        it('should map a name to the matching name', () => {
          assert.equal(
            ServiceCatalogs.mapCatalogName({id: name, type: SCET.STRING}),
            name
          );
        });

        it('should return undefined if an index doesn\'t exist', () => {
          assert.isUndefined(
            ServiceCatalogs.mapCatalogName({id: -1, type: SCET.NUMBER})
          );
        });

        it('should return undefined if a name doesn\'t exist', () => {
          assert.isUndefined(
            ServiceCatalogs.mapCatalogName({id: 'invalid', type: SCET.NUMBER})
          );
        });
      });

      describe('#mapRemoteCatalog()', () => {
        it('should return an array', () => {
          const mappedHosts = ServiceCatalogs.mapRemoteCatalog({
            catalog: 'custom',
            ...fixture
          });

          assert.isArray(mappedHosts);
        });

        it('should include all provided hosts', () => {
          const mappedHosts = ServiceCatalogs.mapRemoteCatalog({
            catalog: 'custom',
            ...fixture
          });

          assert.equal(mappedHosts.length, fixtureHosts.length);
        });

        it('should not map using an invalid catalog name', () => {
          assert.throws(() => ServiceCatalogs.mapRemoteCatalog({
            catalog: 'invalid',
            ...fixture
          }));
        });

        it('should map catalog indexes to catalog names', () => {
          const catalogIndex = 4;

          const mappedHosts = ServiceCatalogs.mapRemoteCatalog({
            catalog: catalogIndex,
            ...fixture
          });

          assert.equal(
            mappedHosts[0].catalog,
            SERVICE_CATALOGS[catalogIndex]
          );
        });
      });
    });
  });
});
