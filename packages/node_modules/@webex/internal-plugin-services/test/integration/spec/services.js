/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

import '@webex/internal-plugin-wdm';
import '@webex/internal-plugin-services';

import {assert} from '@webex/test-helper-chai';
import WebexCore from '@webex/webex-core';
import testUsers from '@webex/test-helper-test-users';
import ServiceUrl from '@webex/internal-plugin-services/src/service-url';

/* eslint-disable no-underscore-dangle */
describe('plugin-services', () => {
  describe('Services', () => {
    let webexUser;
    let webex;
    let services;
    let catalog;

    before('create users', () => testUsers.create({count: 1})
      .then(([user]) => new Promise((resolve) => {
        setTimeout(() => {
          webexUser = user;
          webex = new WebexCore({credentials: {supertoken: user.token}});
          services = webex.internal.services;
          catalog = services._getCatalog();
          resolve();
        }, 3000);
      }))
      .then(() => webex.internal.device.register())
      .then(() => services.waitForCatalog('postauth', 10))
      .then(() => services.updateServices('userId', webexUser.id)));

    describe('#_getCatalog()', () => {
      it('returns a catalog', () => {
        const localCatalog = services._getCatalog();

        assert.equal(localCatalog.namespace, 'ServiceCatalog');
      });
    });

    describe('#list()', () => {
      it('returns list matches values in serviceUrl', () => {
        let serviceList = services.list();

        Object.keys(serviceList).forEach((key) => {
          assert.equal(serviceList[key], catalog._getUrl(key).get());
        });

        serviceList = services.list(true);
        Object.keys(serviceList).forEach((key) => {
          assert.equal(serviceList[key], catalog._getUrl(key).get(true));
        });
      });
    });

    describe('#get()', () => {
      let testUrlTemplate;
      let testUrl;

      beforeEach('load test url', () => {
        testUrlTemplate = {
          defaultUrl: 'https://www.example.com/api/v1',
          hosts: [],
          name: 'exampleValid'
        };
        testUrl = new ServiceUrl({...testUrlTemplate});
        catalog._loadServiceUrls('preauth', [testUrl]);
      });

      it('returns a valid string when name is specified', () => {
        const url = services.get(testUrlTemplate.name);

        assert.typeOf(url, 'string');
        assert.equal(url, testUrlTemplate.defaultUrl);
      });

      it('returns undefined if url doesn\'t exist', () => {
        const s = services.get('invalidUrl');

        assert.typeOf(s, 'undefined');
      });

      it('gets a service from a specific serviceGroup', () => {
        assert.isDefined(services.get(testUrlTemplate.name, false, 'preauth'));
      });

      it('fails to get a service if serviceGroup isn\'t accurate', () => {
        assert.isUndefined(services.get(testUrlTemplate.name,
          false, 'discovery'));
      });

      afterEach('unload test url', () => {
        catalog._unloadServiceUrls('preauth', [testUrl]);
      });
    });

    describe('#markFailedUrl()', () => {
      let testUrlTemplate;
      let testUrl;

      beforeEach('load test url', () => {
        testUrlTemplate = {
          defaultUrl: 'https://www.example.com/api/v1',
          hosts: [
            {
              host: 'www.example-p5.com',
              ttl: -1,
              priority: 5
            },
            {
              host: 'www.example-p3.com',
              ttl: -1,
              priority: 3
            }
          ],
          name: 'exampleValid'
        };
        testUrl = new ServiceUrl({...testUrlTemplate});
        catalog._loadServiceUrls('preauth', [testUrl]);
      });

      it('marks a host as failed and removes from host list', () => {
        const priorityUrl = services.get(testUrlTemplate.name, true);
        const originalServiceUrlHostLength = testUrl.hosts.length;

        services.markFailedUrl(priorityUrl);

        assert.isBelow(testUrl.hosts.length, originalServiceUrlHostLength);
      });

      it('returns the next priority url', () => {
        const priorityUrl = services.get(testUrlTemplate.name, true);

        const nextPriorityUrl = services.markFailedUrl(priorityUrl);

        assert.notEqual(priorityUrl, nextPriorityUrl);
      });

      afterEach('unload test url', () => {
        catalog._unloadServiceUrls('preauth', [testUrl]);
      });
    });

    describe('#updateServices()', () => {
      it('returns a Promise that and resolves on success', (done) => {
        const servicesPromise = services.updateServices();

        assert.typeOf(servicesPromise, 'Promise');

        servicesPromise.then(() => {
          Object.keys(services.list()).forEach((key) => {
            assert.typeOf(key, 'string');
            assert.typeOf(services.list()[key], 'string');
          });

          done();
        });
      });

      it('updates the services list', (done) => {
        catalog.serviceGroups.postauth = [];

        services.updateServices()
          .then(() => {
            assert.isAbove(catalog.serviceGroups.postauth.length, 0);
            done();
          });

        services.updateServices();
      });

      it('updates the limited catalog when email is provided', (done) => {
        catalog.serviceGroups.preauth = [];

        services.updateServices('limited', 'email', webexUser.email)
          .then(() => {
            assert.isAbove(catalog.serviceGroups.preauth.length, 0);
            done();
          });
      });

      it('updates the limited catalog when userId is provided', (done) => {
        catalog.serviceGroups.preauth = [];

        services.updateServices('limited', 'userId', webexUser.id)
          .then(() => {
            assert.isAbove(catalog.serviceGroups.preauth.length, 0);
            done();
          });
      });

      it('updates the limited catalog when orgId is provided', (done) => {
        catalog.serviceGroups.preauth = [];

        services.updateServices('limited', 'orgId', webexUser.orgId)
          .then(() => {
            assert.isAbove(catalog.serviceGroups.preauth.length, 0);
            done();
          });
      });
    });

    describe('#collectPreauthCatalog()', () => {
      const unauthWebex = new WebexCore({config: {credentials: {federation: true}}});
      const unauthServices = unauthWebex.internal.services;

      it('requires an email as the parameter', () => unauthServices.collectPreauthCatalog()
        .catch((e) => {
          assert(true, e);
        }));

      it('updates the preauth catalog', () => unauthServices.collectPreauthCatalog(webexUser.email)
        .then(() => {
          assert.isAbove(Object.keys(unauthServices.list()).length, 0);
        }));
    });

    describe('#collectSigninCatalog()', () => {
      const unauthWebex = new WebexCore({config: {credentials: {federation: true}}});
      const unauthServices = unauthWebex.internal.services;

      it('requires an email as the parameter', () => unauthServices.collectPreauthCatalog()
        .catch((e) => {
          assert(true, e);
        }));

      it('requires a token as the parameter', () => unauthServices.collectPreauthCatalog('email@website.com')
        .catch((e) => {
          assert(true, e);
        }));

      it('updates the preauth catalog', () => unauthServices.collectPreauthCatalog(webexUser.email)
        .then(() => {
          assert.isAbove(Object.keys(unauthServices.list()).length, 0);
        }));
    });

    describe('#_fetchNewServiceHostmap()', () => {
      let fullRemoteHM;
      let limitedRemoteHM;

      beforeEach(() => Promise.all([
        services._fetchNewServiceHostmap(),
        services._fetchNewServiceHostmap('limited', 'userId', webexUser.id)
      ])
        .then(([fRHM, lRHM]) => {
          fullRemoteHM = fRHM;
          limitedRemoteHM = lRHM;

          return Promise.resolve();
        }));

      it('returns a promise', () => {
        assert.typeOf(services._fetchNewServiceHostmap(), 'Promise');
      });

      it('resolves to an authed u2c hostmap when no params specified', () => {
        assert.typeOf(fullRemoteHM, 'array');
        assert.isAbove(fullRemoteHM.length, 0);
      });

      it('resolves to a limited u2c hostmap when params specified', () => {
        assert.typeOf(limitedRemoteHM, 'array');
        assert.isAbove(limitedRemoteHM.length, 0);
      });

      it('rejects if the params provided are invalid', () => (
        services._fetchNewServiceHostmap('limited', 'userId', 'notValid')
          .then(() => {
            assert.isTrue(false, 'should have rejected');

            return Promise.reject();
          })
          .catch((e) => {
            assert.typeOf(e, 'Error');

            return Promise.resolve();
          })
      ));
    });
  });
});
/* eslint-enable no-underscore-dangle */
