import Url from 'url';

import {base64} from '@webex/common';
import {WebexPlugin} from '@webex/webex-core';

import ServiceCatalog from './service-catalog';

/* eslint-disable no-underscore-dangle */
/**
 * @class
 */
const Services = WebexPlugin.extend({
  namespace: 'Services',

  _catalogs: new WeakMap(),

  /**
   * **Internal**
   * Get the current catalog based on the assocaited
   * webex instance.
   * @returns {ServiceCatalog}
   */
  _getCatalog() {
    return this._catalogs.get(this.webex);
  },

  /**
   * Get a service url from the current services list by name
   * from the associated instance catalog.
   * @param {string} name
   * @param {boolean} [priorityHost]
   * @param {string} [serviceGroup]
   * @returns {string|undefined}
   */
  get(name, priorityHost, serviceGroup) {
    const catalog = this._getCatalog();

    return catalog.get(name, priorityHost, serviceGroup);
  },

  /**
   * Generate a service catalog as an object from
   * the associated instance catalog.
   * @param {boolean} [priorityHost] - use highest priority host if set to `true`
   * @param {string} [serviceGroup]
   * @returns {Record<string, string>}
   */
  list(priorityHost, serviceGroup) {
    const catalog = this._getCatalog();

    return catalog.list(priorityHost, serviceGroup);
  },

  /**
   * Mark a priority host service url as failed.
   * This will mark the host associated with the
   * `ServiceUrl` to be removed from the its
   * respective host array, and then return the next
   * viable host from the `ServiceUrls` host array,
   * or the `ServiceUrls` default url if no other priority
   * hosts are available, or if `noPriorityHosts` is set to
   * `true`.
   * @param {string} url
   * @param {boolean} noPriorityHosts
   * @returns {string}
   */
  markFailedUrl(url, noPriorityHosts) {
    const catalog = this._getCatalog();

    return catalog.markFailedUrl(url, noPriorityHosts);
  },

  /**
   * Update a list of `serviceUrls` to the most current
   * catalog via the defined `discoveryUrl` then returns the current
   * list of services.
   * @param {string} [from] - This accepts `limited` or `signin`
   * @param {string} [by] - This accepts `email`, `orgId` or `userId`
   * @param {string} [value] - This accepts an email, orgId, or userId
   * @param {string} [token] - used for signin catalog
   * @returns {Promise<void>}
   */
  updateServices(from, by, value, token) {
    const catalog = this._getCatalog();
    let serviceGroup;

    if (from === 'signin' && !token) {
      Promise.reject(new Error(
        'token is required when updating signin catalog'
      ));
    }

    switch (from) {
      case 'limited': serviceGroup = 'preauth'; break;
      case 'signin': serviceGroup = 'signin'; break;
      default: serviceGroup = 'postauth'; break;
    }

    if (catalog.status[serviceGroup].collecting) {
      return this.waitForCatalog(serviceGroup);
    }

    catalog.status[serviceGroup].collecting = true;

    const params = [];

    if (by && value) {
      params.push(
        from,
        by,
        by === 'email' ? base64.encode(value) : value,
        token
      );
    }

    return this._fetchNewServiceHostmap(...params)
      .then((serviceHostMap) => {
        catalog.updateServiceUrls(
          serviceGroup,
          serviceHostMap
        );

        catalog.status[serviceGroup].collecting = false;

        return Promise.resolve();
      })
      .catch(() => {
        catalog.status[serviceGroup].collecting = false;

        return Promise.reject();
      });
  },

  /**
   * simplified method to update the preauth catalog via email
   * @param {string} email
   * @returns {Promise<void>}
   */
  collectPreauthCatalog(email) {
    if (!email) {
      return Promise.reject(new Error('`email` is required'));
    }

    return this.updateServices('limited', 'email', email);
  },

  /**
   * simplified method to update the signin catalog via email and token
   * @param {string} email
   * @param {string} token
   * @returns {Promise<void>}
   */
  collectSigninCatalog(email, token) {
    if (!email) {
      return Promise.reject(new Error('`email` is required'));
    }
    if (!token) {
      return Promise.reject(new Error('`token` is required'));
    }

    return this.updateServices('signin', 'email', email, token);
  },

  /**
   * Wait until the service catalog is available,
   * or reject afte ra timeout of 60 seconds.
   * @param {string} serviceGroup
   * @param {number} [timeout] - in seconds
   * @returns {Promise<void>}
   */
  waitForCatalog(serviceGroup, timeout) {
    const catalog = this._getCatalog();

    if (serviceGroup === 'postauth' &&
      this.webex.credentials.canAuthorize &&
      !catalog.status.postauth.collecting
    ) {
      return this.updateServices();
    }

    return catalog.waitForCatalog(serviceGroup, timeout);
  },

  /**
   *  **Internal**
   * Organize a received hostmap from a service
   * catalog endpoint.
   * @param {object} serviceHostmap
   * @returns {object}
   */
  _formatReceivedHostmap(serviceHostmap) {
    const output = [];
    let item = {};

    Object.keys(serviceHostmap.serviceLinks).forEach((key) => {
      item = {};

      item.name = key;
      item.defaultUrl = serviceHostmap.serviceLinks[key];
      item.hosts = serviceHostmap.hostCatalog[Url.parse(item.defaultUrl).host];

      output.push(item);
    });

    return output;
  },

  /**
   * **Internal**
   * Simplified method wrapper for sending a request to get
   * an updated service hostmap.
   * @param {string} [from]
   * @param {string} [by]
   * @param {string} [value]
   * @param {string} [token]
   * @returns {Promise<object>}
   */
  _fetchNewServiceHostmap(from, by, value, token) {
    const service = 'u2c';
    const limStr = (from) ? `/${from}` : '';
    const qs = {
      format: 'hostmap'
    };

    if (from) {
      qs[by] = value;
    }

    const requestObj = {
      method: 'GET',
      service,
      resource: `${limStr}/catalog`,
      qs
    };

    if (token) {
      requestObj.headers = {
        authorization: token
      };
    }

    return this.request(requestObj)
      .then(({body}) => Promise.resolve(this._formatReceivedHostmap(body)))
      .catch((e) => Promise.reject(e));
  },

  /**
   * Initializer
   *
   * @instance
   * @memberof Services
   * @returns {Services}
   */
  initialize() {
    this._catalogs.set(this.webex, new ServiceCatalog());

    this.listenToOnce(this.webex, 'ready', () => {
      /* eslint-disable camelcase */
      if (this.webex.credentials.canAuthorize) {
        this.updateServices();
      }
      else if (this.webex.config.email) {
        this.updateServices('limited', 'email', this.webex.config.email);
      }
      /* eslint-enable camelcase */
    });
  }
});
/* eslint-enable no-underscore-dangle */

export default Services;
