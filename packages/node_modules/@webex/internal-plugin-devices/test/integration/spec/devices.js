import '@webex/internal-plugin-devices';

import {assert} from '@webex/test-helper-chai';
import sinon from 'sinon';
import testUsers from '@webex/test-helper-test-users';
import WebexCore, {WebexHttpError} from '@webex/webex-core';


describe('plugin-devices', () => {
  describe('Devices', () => {
    let webex;
    let devices;
    let user;

    before('create users', () => testUsers.create({count: 1})
      .then(([definedUser]) => {
        user = definedUser;
      }));

    beforeEach('create webex instance', () => {
      webex = new WebexCore({
        credentials: user.token
      });

      devices = webex.internal.devices;
    });

    // Do nothing on error, as some methods utilize sinon for `unregister()`.
    afterEach('attempt to unregister the device', () => devices.unregister()
      .catch(() => {}));

    after('remove users', () => testUsers.remove([user]));

    describe('#canRegister()', () => {
      describe('when wait is truthy', () => {
        let wait;

        beforeEach('set wait', () => {
          wait = true;
        });

        describe('when the `wdm` service is available', () => {
          let services;

          beforeEach('destructure services plugin', () => {
            services = webex.internal.services;

            return services.waitForCatalog('postauth');
          });

          it('returns a resolved promise', () => {
            assert.isDefined(services.get('wdm'));

            return devices.canRegister(wait)
              .then(() => assert.isTrue(true, 'resolved the promise'));
          });
        });

        describe('when the service catalog is not ready', () => {
          let services;

          beforeEach('setup catalog to be not ready', () => {
            services = webex.internal.services;

            services.updateServices();
          });

          it('waits for the catalog then returns a resolved promise', () => {
            /* eslint-disable-next-line no-underscore-dangle */
            assert.isTrue(services._getCatalog().status.postauth.collecting);

            return devices.canRegister(wait)
              .then(() => assert.isTrue(true, 'resolved the promise'));
          });
        });

        describe('when the `wdm` service is not available', () => {
          let catalog;
          let services;

          beforeEach('remove wdm service', () => {
            services = webex.internal.services;
            /* eslint-disable-next-line no-underscore-dangle */
            catalog = services._getCatalog();

            catalog.serviceGroups.postauth = [];
          });

          it('returns a rejected promise', () => {
            assert.isUndefined(services.get('wdm'));

            return devices.canRegister(wait)
              .then(() => assert.isTrue(false, 'resolved the promise'))
              .catch(() => assert.isTrue(true, 'rejected the promise'));
          });
        });
      });

      describe('when wait is falsy', () => {
        let wait;

        beforeEach('set wait', () => {
          wait = false;
        });

        describe('when the `wdm` service is available', () => {
          let services;

          beforeEach('destructure services plugin', () => {
            services = webex.internal.services;

            return services.updateServices();
          });

          it('returns a resolved promise', () => {
            assert.isDefined(services.get('wdm'));

            return devices.canRegister(wait)
              .then(() => assert.isTrue(true, 'resolved the promise'));
          });
        });

        describe('when the service catalog is not ready', () => {
          let catalog;
          let services;

          beforeEach('setup catalog to be not ready', () => {
            services = webex.internal.services;
            /* eslint-disable-next-line no-underscore-dangle */
            catalog = services._getCatalog();

            catalog.serviceGroups.postauth = [];

            services.updateServices();
          });

          it('returns a rejected promise', () => {
            /* eslint-disable-next-line no-underscore-dangle */
            assert.isTrue(services._getCatalog().status.postauth.collecting);

            return devices.canRegister(wait)
              .then(() => assert.isTrue(false, 'resolved the promise'))
              .catch(() => assert.isTrue(true, 'rejected the promise'));
          });
        });

        describe('when the `wdm` service is not available', () => {
          let catalog;
          let services;

          beforeEach('setup catalog to be not ready', () => {
            services = webex.internal.services;
            /* eslint-disable-next-line no-underscore-dangle */
            catalog = services._getCatalog();

            catalog.serviceGroups.postauth = [];
          });

          it('returns a rejected promise', () => {
            assert.isUndefined(services.get('wdm'));

            return devices.canRegister(wait)
              .then(() => assert.isTrue(false, 'resolved the promise'))
              .catch(() => assert.isTrue(true, 'rejected the promise'));
          });
        });
      });
    });

    describe('#checkNetworkReachability()', () => {
      describe('when the reachability check has already been completed', () => {
        beforeEach('set reachability checked to true', () => {
          devices.isReachabilityChecked = true;
        });

        it('returns a resolved promise', () => {
          assert.isTrue(devices.isReachabilityChecked);

          return devices.checkNetworkReachability()
            .then(() => assert.isTrue(true, 'resolved the promise'));
        });
      });

      describe('when there is no intranet inactivity check url', () => {
        beforeEach('setup devices properties', () => {
          devices.intranetInactivityCheckUrl = undefined;
          devices.isReachabilityChecked = false;
        });

        it('sets the in-network property to false', () => {
          assert.isUndefined(devices.intranetInactivityCheckUrl);

          return devices.checkNetworkReachability()
            .then(() => {
              assert.isFalse(devices.isInNetwork);
            });
        });

        it('returns a resolved promise', () => {
          assert.isUndefined(devices.intranetInactivityCheckUrl);

          return devices.checkNetworkReachability()
            .then(() => assert.isTrue(true, 'resolved the promise'));
        });

        describe('when the device has inactivity enforcement', () => {
          let logoutTimer;

          beforeEach('set device to enforce inactivity timers', () => {
            devices.config.enableInactivityEnforcement = true;
            logoutTimer = devices.logoutTimer;
          });

          it('does not reset the logout timer', () => {
            assert.isUndefined(devices.intranetInactivityCheckUrl);

            return devices.checkNetworkReachability()
              .then(() => assert.equal(devices.logoutTimer, logoutTimer));
          });
        });
      });

      describe('when the rechability is performable', () => {
        beforeEach('setup for reachability check', () => {
          // Due to property overriding, `isReachabilityChecked` must be set
          // within each `it` statement.
          devices.isInNetwork = false;
        });

        describe('when the network is reachabable', () => {
          beforeEach('set inactivity check url and stubs', () => {
            devices.intranetInactivityCheckUrl =
              'https://myspark.cisco.com/spark_session_check.json';

            devices.resetLogoutTimer = sinon.spy();

            devices.request = sinon.stub().resolves({});
          });

          it('utilizes \'resetLogoutTimer()\'', () => {
            devices.isReachabilityChecked = false;

            assert.isFalse(devices.isReachabilityChecked);

            return devices.checkNetworkReachability()
              .then(() => assert.called(devices.resetLogoutTimer));
          });

          it('sets the reachability check to true', () => {
            devices.isReachabilityChecked = false;

            assert.isFalse(devices.isReachabilityChecked);

            return devices.checkNetworkReachability()
              .then(() => assert.isTrue(devices.isReachabilityChecked));
          });

          it('sets the in-network property to true', () => {
            devices.isReachabilityChecked = false;

            assert.isFalse(devices.isInNetwork);

            return devices.checkNetworkReachability()
              .then(() => assert.isTrue(devices.isInNetwork));
          });

          it('returns a resolved promise',
            () => devices.checkNetworkReachability()
              .then(() => assert.isTrue(true, 'resolved the promise')));
        });

        describe('when the network is not reachable', () => {
          beforeEach('unset inactivity check url', () => {
            devices.intranetInactivityCheckUrl =
              'https://myspark.cisco.com/bad-spark_session_check.json';
          });

          it('sets the reachability check to true', () => {
            devices.isReachabilityChecked = false;

            assert.isFalse(devices.isReachabilityChecked);

            return devices.checkNetworkReachability()
              .then(() => assert.isTrue(false, 'resolved the promise'))
              .catch(() => assert.isTrue(devices.isReachabilityChecked));
          });

          it('sets the in-network property to false',
            () => devices.checkNetworkReachability()
              .then(() => assert.isTrue(false, 'resolved the promise'))
              .catch(() => assert.isFalse(devices.isInNetwork)));

          it('returns a rejected promise',
            () => devices.checkNetworkReachability()
              .then(() => assert.isTrue(false, 'resolved the promise'))
              .catch(() => assert.isTrue(true, 'rejected the promise')));
        });
      });
    });

    describe('#getWebSocketUrl()', () => {
      let services;

      beforeEach('destructure services', () => {
        services = webex.internal.services;
      });

      describe('when wait is truthy', () => {
        let wait;

        beforeEach('set wait', () => {
          wait = true;
        });

        describe('when the device is registered', () => {
          beforeEach('register the device', () => devices.register());

          it('returns a resolved promise with the websocket url',
            () => devices.getWebSocketUrl(wait)
              .then((url) => {
                assert.isDefined(url);
                assert.isTrue(services.isServiceUrl(url));
                assert.include(url, 'mercury');
              }));
        });

        describe('when the device is not registered', () => {
          describe('when the device successfully registers', () => {
            beforeEach(() => {
              // This needs to not be returned, as it must be pending during the
              // it clause.
              devices.register();
            });

            it('returns a resolved promise with the websocket url', () => {
              assert.isFalse(devices.registered);

              return devices.getWebSocketUrl(wait)
                .then((url) => {
                  assert.isDefined(url);
                  assert.isTrue(services.isServiceUrl(url));
                  assert.include(url, 'mercury');
                });
            });
          });

          describe('when the device never registers', () => {
            it('returns a rejected promise', () => {
              assert.isFalse(devices.registered);

              return devices.getWebSocketUrl(wait)
                .then(() => assert.isTrue(false, 'resolved the promise'))
                .catch(() => assert.isTrue(true, 'rejected the promise'));
            });
          });
        });
      });

      describe('when wait is falsy', () => {
        let wait;

        beforeEach('set wait', () => {
          wait = false;
        });

        describe('when the device is registered', () => {
          beforeEach('register the device', () => devices.register());

          describe('when the priority host can be mapped', () => {
            it('returns a resolved promise with the websocket url', () => {
              assert.isDefined(services.get('wdm'));
              assert.isTrue(devices.registered);

              return devices.getWebSocketUrl(wait)
                .then((url) => {
                  assert.isDefined(url);
                  assert.isTrue(services.isServiceUrl(url));
                  assert.include(url, 'mercury');
                });
            });
          });

          describe('when the priority host cannot be mapped', () => {
            beforeEach('remove postauth services', () => {
              /* eslint-disable-next-line no-underscore-dangle */
              services._getCatalog().serviceGroups.postauth = [];
            });

            it('returns a rejected promise',
              () => devices.getWebSocketUrl(wait)
                .then(() => assert.isTrue(false, 'resolved the promise'))
                .catch(() => assert.isTrue(true, 'rejected the promise')));
          });
        });

        describe('when the device is not registered', () => {
          it('returns a rejected promise', () => {
            assert.isFalse(devices.registered);

            return devices.getWebSocketUrl(wait)
              .then(() => assert.isTrue(false, 'resolved the promise'))
              .catch(() => assert.isTrue(true, 'rejected the promise'));
          });
        });
      });
    });

    describe('#meetingStarted()', () => {
      let spyFunction;

      beforeEach('setup instance function', () => {
        spyFunction = sinon.spy();
      });

      it('triggers a \'meeting started\' event', () => {
        webex.on('meeting started', spyFunction);
        devices.meetingStarted();
        assert.called(spyFunction);
      });
    });

    describe('#meetingEnded()', () => {
      let spyFunction;

      beforeEach('setup instance function', () => {
        spyFunction = sinon.spy();
      });

      it('triggers a \'meeting ended\' event', () => {
        webex.on('meeting ended', spyFunction);
        devices.meetingEnded();
        assert.called(spyFunction);
      });
    });

    describe('#processRegistrationSuccess()', () => {
      let customResponse;
      let spyFunction;

      beforeEach('setup parameters', () => {
        customResponse = {
          body: {
            exampleKey: 'exampleValue'
          }
        };

        spyFunction = sinon.spy();
      });

      it('sets the device properties to the values within the response', () => {
        devices.processRegistrationSuccess(customResponse);
        assert.equal(devices.exampleKey, customResponse.body.exampleKey);
      });

      it('triggers a \'registration:success\' event', () => {
        devices.on('registration:success', spyFunction);
        devices.processRegistrationSuccess(customResponse);
        assert.called(spyFunction);
      });

      describe('when the device is ephemeral', () => {
        beforeEach('set the device to ephemeral', () => {
          devices.config.ephemeral = true;
        });

        it('creates a refresh timer', () => {
          const {refreshTimer} = devices;

          devices.processRegistrationSuccess(customResponse);
          assert.notEqual(devices.refreshTimer, refreshTimer);
        });
      });
    });

    describe('#refresh()', () => {
      describe('when the device can register', () => {
        describe('when the device is not registered', () => {
          beforeEach('setup spy function', () => {
            devices.register = sinon.spy();
          });

          it('attempts to register', () => {
            assert.isFalse(devices.registered);

            return devices.refresh()
              .then(() => assert.called(devices.register));
          });
        });

        describe('when the device is registered', () => {
          let exampleResponse;

          beforeEach('register the device', () => {
            exampleResponse = {
              body: {
                exampleKey: 'example response value'
              }
            };

            return devices.register()
              .then(() => {
                devices.request = sinon.stub().returns(Promise.resolve(
                  {...exampleResponse}
                ));
              });
          });

          describe('when the device is ephemeral', () => {
            beforeEach('set device to ephemeral', () => {
              devices.config.ephemeral = true;
            });

            it('sets the ttl property to the config values',
              () => devices.refresh()
                .then(() =>
                  assert.calledWith(devices.request, sinon.match.hasNested(
                    'body.ttl', devices.config.ephemeralDeviceTTL
                  ))));
          });

          describe('when the refresh request is sent', () => {
            let customHeaders;
            let customBody;

            beforeEach('configure devices plugin', () => {
              customHeaders = {
                testHeader: 'example header value'
              };

              customBody = {
                testBody: 'example body value'
              };
            });

            it('allows for custom header key:values', () => {
              assert.isTrue(devices.registered);

              devices.config.headers = {...customHeaders};

              return devices.refresh()
                .then(() =>
                  assert.calledWith(devices.request, sinon.match.hasNested(
                    'headers.testHeader', customHeaders.testHeader
                  )));
            });

            it('allows for custom body key:values', () => {
              assert.isTrue(devices.registered);

              devices.config.body = {...customBody};

              return devices.refresh()
                .then(() =>
                  assert.calledWith(devices.request, sinon.match.hasNested(
                    'body.testBody', customBody.testBody
                  )));
            });

            it('uses the device\'s url property', () => {
              assert.isTrue(devices.registered);

              devices.config.body = {...customBody};

              return devices.refresh()
                .then(() =>
                  assert.calledWith(devices.request, sinon.match.has(
                    'uri', devices.url
                  )));
            });

            it('sends a PUT request', () => {
              assert.isTrue(devices.registered);

              devices.config.body = {...customBody};

              return devices.refresh()
                .then(() =>
                  assert.calledWith(devices.request, sinon.match.has(
                    'method', 'PUT'
                  )));
            });
          });

          describe('when the device is successfully refreshes', () => {
            beforeEach('setup stubs', () => {
              devices.processRegistrationSuccess = sinon.stub();
            });

            it('returns a resolved promise', () => devices.refresh()
              .then(() => assert.isTrue(true, 'resolved the promise')));

            it('calls \'processRegistrationSuccess()\'', () => devices.refresh()
              .then(() => assert.called(devices.processRegistrationSuccess)));
          });

          describe('when the device fails to refresh', () => {
            beforeEach('setup \'register()\' stub', () => {
              devices.register = sinon.spy();
            });

            describe('when the device is not found', () => {
              beforeEach('setup request stub to 404', () => {
                devices.request = sinon.stub().rejects(
                  new WebexHttpError({
                    statusCode: 404,
                    options: {
                      url: devices.url,
                      headers: {
                        trackingId: 'tid'
                      }
                    }
                  })
                );
              });

              it('clears the current device', () => devices.refresh()
                .then(() => assert.isUndefined(devices.url)));

              it('attempts to register a new device', () => devices.refresh()
                .then(() => assert.called(devices.register)));
            });

            describe('when the device was found', () => {
              beforeEach('setup request stub to 503', () => {
                devices.request = sinon.stub().rejects(
                  new WebexHttpError({
                    statusCode: 503,
                    options: {
                      url: devices.url,
                      headers: {
                        trackingId: 'tid'
                      }
                    }
                  })
                );
              });

              it('returns a rejected promise', () => devices.refresh()
                .then(() => assert.isTrue(false, 'resolved the promise'))
                .catch(() => assert.isTrue(true, 'rejected the promise')));
            });
          });
        });
      });

      describe('when the device cannot register', () => {
        beforeEach('setup \'canRegister()\' stub', () => {
          devices.canRegister = sinon.stub().rejects(
            new Error()
          );
        });

        it('returns a rejected promise', () => devices.refresh()
          .then(() => assert.isTrue(false, 'resolved the promise'))
          .catch(() => assert.isTrue(true, 'rejected the promise')));
      });
    });

    describe('#register()', () => {
      describe('when the device can register', () => {
        describe('when the device is already registered', () => {
          beforeEach('setup \'register()\' spy and register', () => {
            devices.refresh = sinon.spy();

            return devices.register();
          });

          it('attempts to refresh', () => {
            assert.isTrue(devices.registered);

            return devices.register()
              .then(() => assert.called(devices.refresh));
          });
        });

        describe('when the device is not already registered', () => {
          let exampleResponse;

          beforeEach('setup stubs and scoped variables', () => {
            exampleResponse = {
              body: {
                exampleKey: 'example response value'
              }
            };

            devices.request = sinon.stub().returns(Promise.resolve(
              {...exampleResponse}
            ));
          });

          describe('when the registration request is sent', () => {
            let customHeaders;
            let customBody;

            beforeEach('configure devices plugin', () => {
              customHeaders = {
                testHeader: 'example header value'
              };

              customBody = {
                testBody: 'example body value'
              };
            });

            it('allows for custom header key:values', () => {
              assert.isFalse(devices.registered);

              devices.config.headers = {...customHeaders};

              return devices.register()
                .then(() =>
                  assert.calledWith(devices.request, sinon.match.hasNested(
                    'headers.testHeader', customHeaders.testHeader
                  )));
            });

            it('allows for custom body key:values', () => {
              assert.isFalse(devices.registered);

              devices.config.body = {...customBody};

              return devices.register()
                .then(() =>
                  assert.calledWith(devices.request, sinon.match.hasNested(
                    'body.testBody', customBody.testBody
                  )));
            });

            it('uses the \'wdm\' service', () => {
              assert.isFalse(devices.registered);

              devices.config.body = {...customBody};

              return devices.register()
                .then(() =>
                  assert.calledWith(devices.request, sinon.match.has(
                    'service', 'wdm'
                  )));
            });

            it('uses the \'devices\' resource', () => {
              assert.isFalse(devices.registered);

              devices.config.body = {...customBody};

              return devices.register()
                .then(() =>
                  assert.calledWith(devices.request, sinon.match.has(
                    'resource', 'devices'
                  )));
            });

            it('sends a POST request', () => {
              assert.isFalse(devices.registered);

              devices.config.body = {...customBody};

              return devices.register()
                .then(() =>
                  assert.calledWith(devices.request, sinon.match.has(
                    'method', 'POST'
                  )));
            });
          });

          describe('when the device is successfully registers', () => {
            beforeEach('setup stubs', () => {
              devices.processRegistrationSuccess = sinon.stub();
            });

            it('returns a resolved promise', () => devices.register()
              .then(() => assert.isTrue(true, 'resolved the promise')));

            it('calls \'processRegistrationSuccess()\'',
              () => devices.register()
                .then(() => assert.called(devices.processRegistrationSuccess)));
          });

          describe('when the device fails to register', () => {
            beforeEach('setup request stub to 503', () => {
              devices.request = sinon.stub().rejects(
                new WebexHttpError({
                  statusCode: 503,
                  options: {
                    url: 'http://not-a-url.com/resource',
                    headers: {
                      trackingId: 'tid'
                    }
                  }
                })
              );
            });

            it('returns a rejected promise', () => devices.register()
              .then(() => assert.isTrue(false, 'resolved the promise'))
              .catch(() => assert.isTrue(true, 'rejected the promise')));
          });
        });
      });

      describe('when the device cannot register', () => {
        beforeEach('setup \'canRegister()\' stub', () => {
          devices.canRegister = sinon.stub().rejects(
            new Error()
          );
        });

        it('returns a rejected promise', () => devices.register()
          .then(() => assert.isTrue(false, 'resolved the promise'))
          .catch(() => assert.isTrue(true, 'rejected the promise')));
      });
    });

    describe('#resetLogoutTimer()', () => {
      describe('when inactivty enforcement is enabled', () => {
        beforeEach('set inactity enforcement and reachability checked', () => {
          devices.config.enableInactivityEnforcement = true;
          devices.isReachabilityChecked = true;
        });

        describe('when the user is in a meeting', () => {
          beforeEach('set user to be in a meeting', () => {
            devices.isInMeeting = true;
          });

          it('it does not set the logout timer', () => {
            devices.resetLogoutTimer();

            assert.isUndefined(devices.logoutTimer);
          });
        });

        describe('when the user is not in a meeting', () => {
          beforeEach('setup the \'setLogoutTimer()\' spy', () => {
            devices.setLogoutTimer = sinon.stub();
          });

          describe('when the user is in network', () => {
            beforeEach('set user to be in network', () => {
              devices.isInNetwork = true;
            });

            it('sets the logout timer to the in-network duration', () => {
              devices.resetLogoutTimer();

              assert.calledWith(
                devices.setLogoutTimer,
                devices.intranetInactivityCheckUrl
              );
            });
          });

          describe('when the user is not in network', () => {
            it('sets the logout timer to the intranet duration', () => {
              devices.resetLogoutTimer();

              assert.calledWith(
                devices.setLogoutTimer,
                devices.intranetInactivityDuration
              );
            });
          });
        });
      });
    });

    describe('#unregister()', () => {
      describe('when the device is registered', () => {
        beforeEach('register the device', () => devices.register());

        describe('when the unregistration request is sent', () => {
          let url;

          beforeEach('setup the \'request()\' stub', () => {
            devices.request = sinon.stub().resolves();
            url = devices.url;
          });

          it('uses the device\'s url property', () => {
            assert.isTrue(devices.registered);

            return devices.unregister()
              .then(() =>
                assert.calledWith(devices.request, sinon.match.has(
                  'uri', url
                )));
          });

          it('sends a DELETE request', () => {
            assert.isTrue(devices.registered);

            return devices.unregister()
              .then(() =>
                assert.calledWith(devices.request, sinon.match.has(
                  'method', 'DELETE'
                )));
          });
        });

        describe('when the device unregistration request is successful', () => {
          it('clears the device properties', () => devices.unregister()
            .then(() => assert.isUndefined(devices.url)));
        });

        describe('when the device unregistration request fails', () => {
          beforeEach('setup the \'request\' stub', () => {
            devices.request = sinon.stub().rejects(
              new WebexHttpError({
                statusCode: 404,
                options: {
                  url: devices.url,
                  headers: {
                    trackingId: 'tid'
                  }
                }
              })
            );
          });

          it('returns a rejected promise', () => devices.unregister()
            .then(() => assert.isTrue(false, 'resolved the promise'))
            .catch(() => assert.isTrue(true, 'rejected the promise')));
        });
      });

      describe('when the device is not registered', () => {
        it('returns a resolved promise', () => devices.unregister()
          .then(() => assert.isTrue(true, 'resolved the promise')));
      });
    });

    describe('#waitForRegistration()', () => {
      describe('when the device is registered', () => {
        beforeEach('register the device', () => devices.register());

        it('returns a resolved promise', () => devices.waitForRegistration()
          .then(() => assert.isTrue(true, 'resolved the promise')));
      });

      describe('when the device is not registered', () => {
        describe('when the device registers', () => {
          beforeEach('trigger a pending device registration', () => {
            devices.register();
          });

          it('returns a resolved promise once registered', () => {
            assert.isFalse(devices.registered);

            return devices.waitForRegistration()
              .then(() => assert.isTrue(devices.registered));
          });
        });

        describe('when the device does not register', () => {
          it('returns a rejected promise', () => devices.waitForRegistration()
            .then(() => assert.isTrue(false, 'resolved the promise'))
            .catch(() => assert.isTrue(true, 'rejected the promise')));
        });
      });
    });
  });
});
